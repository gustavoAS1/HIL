// Código Conversor Buck-Boost implementado no CCS do DSP Launch f28379d
// Gustavo Araújo de Souza - 16.1.8363
// Universidade Federal de Ouro preto


// Geração de interrupção por ciclo de chaveamento com ADC sincronizado.

#include "F28x_Project.h"
#include <stdio.h>
#include <stdlib.h>
#include <math.h>


volatile struct DAC_REGS* DAC_PTR[4] = {0x0,&DacaRegs,&DacbRegs,&DaccRegs};   // necessário para o DAC funcionar


#define EPWM1_TIMER_TBPRD  400  // Definição para frequência de interrupção : 200khz/fsw
#define EPWM1_MAX_CMPA    250
#define EPWM1_MIN_CMPB       50

//Defines para frequencia de chaveamento do PWM 2
#define EPWM2_TIMER_TBPRD  400 // 333khz           200khz/fsw
#define EPWM2_MAX_CMPA    100
#define EPWM2_MIN_CMPB       50



//Defines para frequencia de chaveamento do PWM 3
#define EPWM3_TIMER_TBPRD  400  //      200Mhz/(Freq);
#define EPWM3_MAX_CMPA    250
#define EPWM3_MIN_CMPB       50


//Defines para frequencia de chaveamento do PWM 4
#define EPWM4_TIMER_TBPRD  400     //  200Mhz/(Freq);
#define EPWM4_MAX_CMPA    250
#define EPWM4_MIN_CMPB    50

//Defines para frequencia de chaveamento do PWM 5
#define EPWM5_TIMER_TBPRD  400     //  200Mhz/(Freq);
#define EPWM5_MAX_CMPA    250
#define EPWM5_MIN_CMPB    50

//Defines para frequencia de chaveamento do PWM 6
#define EPWM6_TIMER_TBPRD  400     //  200Mhz/(Freq);
#define EPWM6_MAX_CMPA    250
#define EPWM6_MIN_CMPB    50



//Prototipo das funcoes
void InitEPwm6Example(void);    //Configura o PWM e inicializa
void InitEPwm5Example(void);    //Configura o PWM e inicializa
void InitEPwm2Example(void);    //Configura o PWM e inicializa
void InitEPwm3Example(void);    //Configura o PWM e inicializa
void InitEPwm4Example(void);    //Configura o PWM e inicializa
void InitEPwm1Example(void);    //Configura o PWM e inicializa

void ConfigureADC(void);        //Configura e inicializa o ADC
void SetupADCSoftware(void);    //Configura os canais de aquisicao do ADC

interrupt void adca1_isr(void); //interrupcao do ADC

void configureDAC(Uint16 dac_num);

// Declaração de variáveis

float D=0.0;
float  i=0.0, di=0.0, Vb=24.0;
float L=0.020, RL=0.1;
float C=0.080, R=5.0;
float Vc=0.0, dVc=0.0;
int i_dac = 0, Vc_dac = 0;

float LL=0.0, CC=0.0, RR=0.0, RC=0.0;
float T=0.000002;



void main(void){
    //Inicializa o sistema (watchdogtimer, pll, sysclock)
    InitSysCtrl();

    //Habilita as GPIO
    InitGpio();

    CpuSysRegs.PCLKCR2.bit.EPWM1=1;
    CpuSysRegs.PCLKCR2.bit.EPWM2=1;
    CpuSysRegs.PCLKCR2.bit.EPWM3=1;
    CpuSysRegs.PCLKCR2.bit.EPWM4=1;
    CpuSysRegs.PCLKCR2.bit.EPWM5=1;
    CpuSysRegs.PCLKCR2.bit.EPWM6=1;

    //Habilita o pino do PWM2
    InitEPwm1Gpio();
    InitEPwm2Gpio();
    InitEPwm3Gpio();
    InitEPwm4Gpio();
    InitEPwm5Gpio();
    InitEPwm6Gpio();
    //Limpa todas as interrupcoes e inicializa a tabela de vetores de interrupcao
    DINT;

    //Inicializa em seu estado padrao os registradores de controle de interrupcoes PIE
    InitPieCtrl();




    //Desabilita interrupcoes da CPU e limpa todas as flags de interrupcao da CPU
    IER = 0x0000;
    IFR = 0x0000;

    // Initialize the PIE vector table with pointers to the shell Interrupt
    // Service Routines (ISR).
    InitPieVectTable();

    //Interrupcoes
    EALLOW; //Habilita escrita em registradores protegidos
    PieVectTable.ADCA1_INT = &adca1_isr; //funcao para interrupcao do ADCA
    EDIS;   //Desabilita escrita em registradores protegidos

    // Inicializa o PWM2 e sincroniza
    EALLOW;
    CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 0;
    EDIS;

    InitEPwm6Example();
    InitEPwm5Example();
    InitEPwm4Example();
    InitEPwm3Example();
    InitEPwm2Example();
    InitEPwm1Example();


    EALLOW;
    CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 1;
    ClkCfgRegs.PERCLKDIVSEL.bit.EPWMCLKDIV=0; /// seta div do pwm
    EDIS;

    //Habilita interrupcoes globais
    IER |= M_INT1; //Habilita grupo 1 das interrupcoes
    EINT;  // Enable Global interrupt INTM
    ERTM;  // Enable Global realtime interrupt DBGM

    PieCtrlRegs.PIEIER1.bit.INTx1 = 1;


    EALLOW;
         GpioCtrlRegs.GPBPUD.bit.GPIO40= 0; //Enable pullup on GPI32; porta 36 habilitada
         GpioCtrlRegs.GPBMUX1.bit.GPIO40= 0; //GPI42= porta IO
         GpioCtrlRegs.GPBDIR.bit.GPIO40= 0; //GPI42= input

         GpioDataRegs.GPBCLEAR.bit.GPIO40=1;


         GpioCtrlRegs.GPBPUD.bit.GPIO41= 0; //Enable pullup on GPI32; porta 36 habilitada
         GpioCtrlRegs.GPBMUX1.bit.GPIO41= 0; //GPI43= porta IO
         GpioCtrlRegs.GPBDIR.bit.GPIO41= 0; //GPI43= input

         GpioDataRegs.GPBCLEAR.bit.GPIO41=1;


         GpioCtrlRegs.GPBPUD.bit.GPIO52= 0;
         GpioCtrlRegs.GPBMUX2.bit.GPIO52= 0;
         GpioCtrlRegs.GPBDIR.bit.GPIO52= 0; // GPIO as input

         GpioDataRegs.GPBCLEAR.bit.GPIO52=1;


         GpioCtrlRegs.GPCPUD.bit.GPIO65= 0;
         GpioCtrlRegs.GPCMUX1.bit.GPIO65= 0;
         GpioCtrlRegs.GPCDIR.bit.GPIO65= 0;   // GPIO as intput

         GpioDataRegs.GPCCLEAR.bit.GPIO65=1;

         GpioCtrlRegs.GPCPUD.bit.GPIO94= 0;
         GpioCtrlRegs.GPCMUX2.bit.GPIO94= 0;
         GpioCtrlRegs.GPCDIR.bit.GPIO94= 1;   // GPIO as output

         GpioDataRegs.GPCCLEAR.bit.GPIO94=1;

         GpioCtrlRegs.GPBPUD.bit.GPIO32= 0;
         GpioCtrlRegs.GPBMUX1.bit.GPIO32= 0;
         GpioCtrlRegs.GPBDIR.bit.GPIO32= 0;

         GpioDataRegs.GPBCLEAR.bit.GPIO32=1;


         GpioCtrlRegs.GPAPUD.bit.GPIO19= 0;
         GpioCtrlRegs.GPAMUX2.bit.GPIO19= 0;
         GpioCtrlRegs.GPADIR.bit.GPIO19= 0; //= input

         GpioDataRegs.GPACLEAR.bit.GPIO19=1;


         GpioCtrlRegs.GPAPUD.bit.GPIO18= 0;
         GpioCtrlRegs.GPAMUX2.bit.GPIO18= 0;
         GpioCtrlRegs.GPADIR.bit.GPIO18= 0; //= input

         GpioDataRegs.GPACLEAR.bit.GPIO18=1;

         GpioCtrlRegs.GPCPUD.bit.GPIO67= 0;
         GpioCtrlRegs.GPCMUX1.bit.GPIO67= 0;
         GpioCtrlRegs.GPCDIR.bit.GPIO67= 0;   // GPIO as output

         GpioDataRegs.GPCCLEAR.bit.GPIO67=1;

         GpioCtrlRegs.GPDPUD.bit.GPIO111= 0;
         GpioCtrlRegs.GPDMUX1.bit.GPIO111= 0;
         GpioCtrlRegs.GPDDIR.bit.GPIO111= 0;   // GPIO as output

         GpioDataRegs.GPDCLEAR.bit.GPIO111=1;


                               /*  EPwm2Regs.CMPA.bit.CMPA = 100;
                                 EPwm2Regs.CMPB.bit.CMPB =100;

                                 EPwm6Regs.CMPA.bit.CMPA = 12500;
                                 EPwm6Regs.CMPB.bit.CMPB =12500;*/


         EDIS;


    // Configura o ADC e inicializa
    ConfigureADC();
    SetupADCSoftware();
    configureDAC(1);
    configureDAC(2);

    LL=1/L;
    CC=1/C;
    RR=1/R;



    //     configureDAC(1); para DACa (Na porta ADCINA0)
    //     configureDAC(2); para DACb (Na porta ADCINA1)
    //     configureDAC(3); para DACc (Na porta ADCINB1)

    do{

    }while(1);
}


void InitEPwm1Example()
{
    // Setup TBCLK
    EPwm1Regs.TBPRD = EPWM1_TIMER_TBPRD;         // para 12 kHz, TBPRD = 1/[freq*(4,00019e-8) ]
    EPwm1Regs.TBPHS.bit.TBPHS = 0x0000;          // Phase is 0
    EPwm1Regs.TBCTR = 0x0000;                    // Clear counter


    // Setup counter mode
    EPwm1Regs.TBCTL.bit.CTRMODE = 0x03; // counter mode: freeze
    EPwm1Regs.TBCTL.bit.PHSEN = TB_DISABLE;        // Disable phase loading
    EPwm1Regs.TBCTL.bit.HSPCLKDIV = TB_DIV1;       // Clock ratio to SYSCLKOUT
    EPwm1Regs.TBCTL.bit.CLKDIV = TB_DIV1;


    // Setup shadowing
    EPwm1Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW;
    EPwm1Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW;
    EPwm1Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; // Load on Zero
    EPwm1Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO;

    EPwm1Regs.TBCTL.bit.CTRMODE = TB_COUNT_UP;

    //  Valores de comparaÃ§Ã£o inicial
    EPwm1Regs.CMPA.bit.CMPA = EPWM1_MAX_CMPA;   // valor inicial do duty p/ pwmA
    EPwm1Regs.CMPB.bit.CMPB = EPWM1_MIN_CMPB;     // valor inicial do duty p/ pwmB


    EPwm1Regs.AQCTLA.bit.ZRO = AQ_SET;            // Set PWM1A on Zero
    EPwm1Regs.AQCTLA.bit.CAU = AQ_CLEAR;          // Clear PWM1A on event A,
                                                        // up count

    EPwm1Regs.AQCTLB.bit.ZRO = AQ_SET;            // Set PWM1B on Zero
    EPwm1Regs.AQCTLB.bit.CBU = AQ_CLEAR;          // Clear PWM1B on event B,
                                                        // up count


}



// InitEPwm2Example - Inicializa ePWM2 e configura
void InitEPwm2Example()
{
    // Setup TBCLK
    EPwm2Regs.TBPRD = EPWM2_TIMER_TBPRD;         // para 12 kHz, TBPRD = 1/[freq*(4,00019e-8) ]
    EPwm2Regs.TBPHS.bit.TBPHS = 0x0000;          // Phase is 0
    EPwm2Regs.TBCTR = 0x0000;                    // Clear counter


    // Setup counter mode
    EPwm2Regs.TBCTL.bit.CTRMODE = 0x03; // counter mode: freeze
    EPwm2Regs.TBCTL.bit.PHSEN = TB_DISABLE;        // Disable phase loading
    EPwm2Regs.TBCTL.bit.HSPCLKDIV = TB_DIV1;       // Clock ratio to SYSCLKOUT
    EPwm2Regs.TBCTL.bit.CLKDIV = TB_DIV1;


    // Setup shadowing
    EPwm2Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW;
    EPwm2Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW;
    EPwm2Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; // Load on Zero
    EPwm2Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO;

    //EPwm2Regs.TBCTL.bit.CTRMODE = TB_COUNT_UPDOWN;
    EPwm2Regs.TBCTL.bit.CTRMODE = TB_COUNT_UP;
    //  Valores de comparaÃ§Ã£o inicial
    EPwm2Regs.CMPA.bit.CMPA = EPWM2_MAX_CMPA;   // valor inicial do duty p/ pwmA
    EPwm2Regs.CMPB.bit.CMPB = EPWM2_MIN_CMPB;     // valor inicial do duty p/ pwmB


      EPwm2Regs.AQCTLA.bit.ZRO = AQ_SET;            // Set PWM1A on Zero
      EPwm2Regs.AQCTLA.bit.CAU = AQ_CLEAR;          // Clear PWM1A on event A,
                                                    // up count

      EPwm2Regs.AQCTLB.bit.ZRO = AQ_SET;            // Set PWM1B on Zero
      EPwm2Regs.AQCTLB.bit.CBU = AQ_CLEAR;          // Clear PWM1B on event B,
                                                    // up count


    // Interrupt where we will change the Compare Values
    EPwm2Regs.ETSEL.bit.SOCAEN = 1;     //Habilita o pulso de EPWM2SOCA
    EPwm2Regs.ETSEL.bit.SOCASEL = 2;    // Este bit determina quando o pulso de conversÃ£o do ePWMA serÃ¡ gerado
    EPwm2Regs.ETPS.bit.SOCAPRD = 1;     //Determina quantos periodos devem ocorrer antes de gerar o pulso do EPWM2SOCA
}

void InitEPwm3Example()
{
    // Setup TBCLK
    EPwm3Regs.TBPRD = EPWM3_TIMER_TBPRD;         // para 12 kHz, TBPRD = 1/[freq*(4,00019e-8) ]
    EPwm3Regs.TBPHS.bit.TBPHS = 0x0000;          // Phase is 0
    EPwm3Regs.TBCTR = 0x0000;                    // Clear counter


    // Setup counter mode
    EPwm3Regs.TBCTL.bit.CTRMODE = 0x03; // counter mode: freeze
    EPwm3Regs.TBCTL.bit.PHSEN = TB_DISABLE;        // Disable phase loading
    EPwm3Regs.TBCTL.bit.HSPCLKDIV = TB_DIV1;       // Clock ratio to SYSCLKOUT
    EPwm3Regs.TBCTL.bit.CLKDIV = TB_DIV1;


    // Setup shadowing
    EPwm3Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW;
    EPwm3Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW;
    EPwm3Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; // Load on Zero
    EPwm3Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO;

    EPwm3Regs.TBCTL.bit.CTRMODE = TB_COUNT_UP;

    //  Valores de comparaÃ§Ã£o inicial
    EPwm3Regs.CMPA.bit.CMPA = EPWM3_MAX_CMPA;   // valor inicial do duty p/ pwmA
    EPwm3Regs.CMPB.bit.CMPB = EPWM3_MIN_CMPB;     // valor inicial do duty p/ pwmB


    EPwm3Regs.AQCTLA.bit.ZRO = AQ_SET;            // Set PWM1A on Zero
    EPwm3Regs.AQCTLA.bit.CAU = AQ_CLEAR;          // Clear PWM1A on event A,
                                                        // up count

    EPwm3Regs.AQCTLB.bit.ZRO = AQ_SET;            // Set PWM1B on Zero
    EPwm3Regs.AQCTLB.bit.CBU = AQ_CLEAR;          // Clear PWM1B on event B,

}


void InitEPwm4Example()
{
    // Setup TBCLK
    EPwm4Regs.TBPRD = EPWM4_TIMER_TBPRD;         // para 12 kHz, TBPRD = 1/[freq*(4,00019e-8) ]
    EPwm4Regs.TBPHS.bit.TBPHS = 0x0000;          // Phase is 0
    EPwm4Regs.TBCTR = 0x0000;                    // Clear counter


    // Setup counter mode
    EPwm4Regs.TBCTL.bit.CTRMODE = 0x03; // counter mode: freeze
    EPwm4Regs.TBCTL.bit.PHSEN = TB_DISABLE;        // Disable phase loading
    EPwm4Regs.TBCTL.bit.HSPCLKDIV = TB_DIV1;       // Clock ratio to SYSCLKOUT
    EPwm4Regs.TBCTL.bit.CLKDIV = TB_DIV1;


    // Setup shadowing
    EPwm4Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW;
    EPwm4Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW;
    EPwm4Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; // Load on Zero
    EPwm4Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO;

    EPwm4Regs.TBCTL.bit.CTRMODE = TB_COUNT_UP;

    //  Valores de comparaÃ§Ã£o inicial
    EPwm4Regs.CMPA.bit.CMPA = EPWM4_MAX_CMPA;   // valor inicial do duty p/ pwmA
    EPwm4Regs.CMPB.bit.CMPB = EPWM4_MIN_CMPB;     // valor inicial do duty p/ pwmB


    EPwm4Regs.AQCTLA.bit.ZRO = AQ_SET;            // Set PWM1A on Zero
    EPwm4Regs.AQCTLA.bit.CAU = AQ_CLEAR;          // Clear PWM1A on event A,
                                                        // up count

    EPwm4Regs.AQCTLB.bit.ZRO = AQ_SET;            // Set PWM1B on Zero
    EPwm4Regs.AQCTLB.bit.CBU = AQ_CLEAR;          // Clear PWM1B on event B,
                                                        // up count

}
void InitEPwm5Example()
{
    // Setup TBCLK
    EPwm5Regs.TBPRD = EPWM5_TIMER_TBPRD;         // para 12 kHz, TBPRD = 1/[freq*(4,00019e-8) ]
    EPwm5Regs.TBPHS.bit.TBPHS = 0x0000;          // Phase is 0
    EPwm5Regs.TBCTR = 0x0000;                    // Clear counter


    // Setup counter mode
    EPwm5Regs.TBCTL.bit.CTRMODE = 0x03; // counter mode: freeze
    EPwm5Regs.TBCTL.bit.PHSEN = TB_DISABLE;        // Disable phase loading
    EPwm5Regs.TBCTL.bit.HSPCLKDIV = TB_DIV1;       // Clock ratio to SYSCLKOUT
    EPwm5Regs.TBCTL.bit.CLKDIV = TB_DIV1;


    // Setup shadowing
    EPwm5Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW;
    EPwm5Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW;
    EPwm5Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; // Load on Zero
    EPwm5Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO;

    EPwm5Regs.TBCTL.bit.CTRMODE = TB_COUNT_UP;

    //  Valores de comparaÃ§Ã£o inicial
    EPwm5Regs.CMPA.bit.CMPA = EPWM4_MAX_CMPA;   // valor inicial do duty p/ pwmA
    EPwm5Regs.CMPB.bit.CMPB = EPWM4_MIN_CMPB;     // valor inicial do duty p/ pwmB


    EPwm5Regs.AQCTLA.bit.ZRO = AQ_SET;            // Set PWM1A on Zero
    EPwm5Regs.AQCTLA.bit.CAU = AQ_CLEAR;          // Clear PWM1A on event A,
                                                        // up count

    EPwm5Regs.AQCTLB.bit.ZRO = AQ_SET;            // Set PWM1B on Zero
    EPwm5Regs.AQCTLB.bit.CBU = AQ_CLEAR;          // Clear PWM1B on event B,
                                                        // up count

}


void InitEPwm6Example()
{
    // Setup TBCLK
    EPwm6Regs.TBPRD = EPWM6_TIMER_TBPRD;         // para 12 kHz, TBPRD = 1/[freq*(4,00019e-8) ]
    EPwm6Regs.TBPHS.bit.TBPHS = 0x0000;          // Phase is 0
    EPwm6Regs.TBCTR = 0x0000;                    // Clear counter


    // Setup counter mode
    EPwm6Regs.TBCTL.bit.CTRMODE = 0x03; // counter mode: freeze
    EPwm6Regs.TBCTL.bit.PHSEN = TB_DISABLE;        // Disable phase loading
    EPwm6Regs.TBCTL.bit.HSPCLKDIV = TB_DIV1;       // Clock ratio to SYSCLKOUT
    EPwm6Regs.TBCTL.bit.CLKDIV = TB_DIV1;


    // Setup shadowing
    EPwm6Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW;
    EPwm6Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW;
    EPwm6Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; // Load on Zero
    EPwm6Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO;

    EPwm6Regs.TBCTL.bit.CTRMODE = TB_COUNT_UP;

    //  Valores de comparaÃ§Ã£o inicial
    EPwm6Regs.CMPA.bit.CMPA = EPWM6_MAX_CMPA;   // valor inicial do duty p/ pwmA
    EPwm6Regs.CMPB.bit.CMPB = EPWM6_MIN_CMPB;     // valor inicial do duty p/ pwmB


    EPwm6Regs.AQCTLA.bit.ZRO = AQ_SET;            // Set PWM1A on Zero
    EPwm6Regs.AQCTLA.bit.CAU = AQ_CLEAR;          // Clear PWM1A on event A,
                                                        // up count

    EPwm6Regs.AQCTLB.bit.ZRO = AQ_SET;            // Set PWM1B on Zero
    EPwm6Regs.AQCTLB.bit.CBU = AQ_CLEAR;          // Clear PWM1B on event B,
                                                        // up count


}

void ConfigureADC(void)
{
    EALLOW;

    //write configurations
    AdcaRegs.ADCCTL2.bit.PRESCALE = 6;
    AdcbRegs.ADCCTL2.bit.PRESCALE = 6;
    //Seta o ADC que sera utilizado, a resolucaoo e o modo de operacao
    AdcSetMode(ADC_ADCA, ADC_RESOLUTION_12BIT, ADC_SIGNALMODE_SINGLE);
    AdcSetMode(ADC_ADCB, ADC_RESOLUTION_12BIT, ADC_SIGNALMODE_SINGLE);

    //Set pulse positions to late
    AdcaRegs.ADCCTL1.bit.INTPULSEPOS = 1;
    AdcbRegs.ADCCTL1.bit.INTPULSEPOS = 1;

    //power up the ADC
    AdcaRegs.ADCCTL1.bit.ADCPWDNZ = 1;
    AdcbRegs.ADCCTL1.bit.ADCPWDNZ = 1;

    //delay for 1ms to allow ADC time to power up
    DELAY_US(1000);

    EDIS;
}

void SetupADCSoftware(void)
{
    Uint16 acqps = 14;  //75ns aquisition time

    //Seleciona os canais para conversao, tempo de aquisicao, e trigger select (ePWM2 SOCA)
    //ADCA
    EALLOW;
    AdcaRegs.ADCSOC0CTL.bit.CHSEL = 0x00;  //SOC0 will convert pin A0
    AdcaRegs.ADCSOC0CTL.bit.ACQPS = acqps; //sample window is acqps +1 SYSCLK cycles
    AdcaRegs.ADCSOC0CTL.bit.TRIGSEL = 0x07; //trigger on ePWM1 SOCA/C
    AdcaRegs.ADCSOC1CTL.bit.CHSEL = 0x02;  //SOC1 will convert pin A2
    AdcaRegs.ADCSOC1CTL.bit.ACQPS = acqps; //sample window is acqps +1 SYSCLK cycles
    AdcaRegs.ADCSOC1CTL.bit.TRIGSEL = 0x07; //trigger on ePWM1 SOCA/C

    AdcaRegs.ADCINTSEL1N2.bit.INT1SEL = 1; //end of SOC1 will set INT1 flag
    AdcaRegs.ADCINTSEL1N2.bit.INT1E = 1;   //enable INT1 flag
    AdcaRegs.ADCINTFLGCLR.bit.ADCINT1 = 1; //make sure INT1 flag is cleared


    //ADCB
    AdcbRegs.ADCSOC0CTL.bit.CHSEL = 0x00;  //SOC0 will convert pin B0
    AdcbRegs.ADCSOC0CTL.bit.ACQPS = acqps; //sample window is acqps +1 SYSCLK cycles
    AdcbRegs.ADCSOC0CTL.bit.TRIGSEL = 0x07; //trigger on ePWM1 SOCA/C

    AdcbRegs.ADCINTSEL1N2.bit.INT1SEL = 1; //end of SOC1 will set INT1 flag
    AdcbRegs.ADCINTSEL1N2.bit.INT1E = 1;   //enable INT1 flag
    AdcbRegs.ADCINTFLGCLR.bit.ADCINT1 = 1; //make sure INT1 flag is cleared
    EDIS;
}

//Interrupcao do ADCA
interrupt void adca1_isr(void)
{

    GpioDataRegs.GPCSET.bit.GPIO94=1;    //pino j5-46

    D=GpioDataRegs.GPBDAT.bit.GPIO40;     // pino j5-50

     //Codigo Main modelado do conversor Buck

     di = (Vb*D + Vc*(1-D) - RL*i)*LL;
    dVc = -Vc*RR*CC - i*(1-D)*CC;


    i = i + di*T;
    if(i<=0.0){i=0.0;}
    Vc = Vc + dVc*T;



   i_dac = i*25;
    Vc_dac = Vc*-33.3333;


    if(i_dac > 4000)
        i_dac = 4000;

    if(Vc_dac > 4000)
        Vc_dac = 4000;


     DAC_PTR[1]->DACVALS.all = i_dac;      // 160A = 3V      pino j3-30
     DAC_PTR[2]->DACVALS.all = Vc_dac;       //  120V = 3V    pino j7-70

    GpioDataRegs.GPCCLEAR.bit.GPIO94=1;

    AdcaRegs.ADCINTFLGCLR.bit.ADCINT1 = 1; //clear INT1 flag
    AdcbRegs.ADCINTFLGCLR.bit.ADCINT1 = 1;
    PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;

}

// configureDAC - Enable and configure the requested DAC module

void configureDAC(Uint16 dac_num)
{
    EALLOW;

    DAC_PTR[dac_num]->DACCTL.bit.DACREFSEL = 1;  // 1 referencia de tensao interna, 0 referencia externa 3.3V no pino ADCINB0
    DAC_PTR[dac_num]->DACOUTEN.bit.DACOUTEN = 1; // habilita o DAC
    DAC_PTR[dac_num]->DACVALS.all = 0;          // inicia o DAC em zero

    DELAY_US(10); // Delay for buffered DAC to power up

    EDIS;
}
